#!/usr/bin/env python

import sys
import os
import re
import matplotlib
import numpy
matplotlib.use('GTK')

from matplotlib.figure import Figure
from matplotlib.axes import Subplot
from matplotlib.backends.backend_gtk import FigureCanvasGTK, NavigationToolbar

import usans

try:
    import pygtk
    pygtk.require("2.0")
    
except:
    pass

try:
    import gtk
    import gtk.glade
except:
    sys.exit(1)



class appGui:
    
    TARGETS = [('STRING', gtk.TARGET_SAME_APP, 0)]
    
    def __init__(self):
        
        gladefile = "bt5plot2.glade"
        self.windowname = "win_Main"
        self.wTree = gtk.glade.XML(gladefile, self.windowname)

        event_dic = {"on_win_Main_destroy" : gtk.main_quit,
                     "on_quit1_activate" : gtk.main_quit,
                     "on_set_data_dir1_activate" : self.setdatadir,
                     "on_xaxis_loglin_activate" : self.handle_xaxis_loglin,
                     "on_yaxis_loglin_activate" : self.handle_yaxis_loglin,
                     "on_plot_type_activate" : self.handle_plot_type_change,
                     "on_btn_ClearPlot_clicked" : self.handle_clearplot,
                     "on_btn_Refresh_clicked" : self.handle_refreshlist,
                     "on_btn_Filter_clicked" : self.handle_filter}
    #                 "on_tv_plotlist_key_press_event" : self.handle_plotlist_keypress}

        #This is a bit clunky, but never mind.
        #Set default plottype to rate. Glade definition sets that as default active button in menu
        self.plottype = 'rate'
        
        self.wTree.signal_autoconnect(event_dic)

        # Set up file list
        self.filelistview = self.wTree.get_widget("tv_filelist")
        
        self.filelist = gtk.ListStore(str, 'gboolean', object, object, object)
        self.filelist.set_sort_column_id(0, gtk.SORT_ASCENDING)

        # Set up filtering of file list
        self.filter_entry = self.wTree.get_widget("ent_filter")
        self.filter_string = []
        self.filter_string.append(self.filter_entry.get_text())
        self.filelistfilter = self.filelist.filter_new()
        self.filelistfilter.set_visible_func(self.filter_filelist,self.filter_string)

        self.filelistview.set_model(self.filelistfilter)

        self.cellrenderertoggle = gtk.CellRendererToggle()
        self.cellrenderertoggle.set_property('activatable', True)
        self.cellrenderertoggle.connect("toggled", self.handle_plot_toggle, self.filelistfilter)
    
        self.AddFileListColumns()

        #fill the file list
        self.FillFileList(self.GetBT5DirList())

        # Set up graphing widget to display xpeek data
        self.figure = Figure(figsize=(4, 4), dpi=72)
        self.axis = self.figure.add_subplot(111)
        self.axis.set_yscale('log')
        self.axis.set_aspect('auto')
        self.axis.set_autoscale_on('True')
        self.axis.set_xlabel('Motor position')
        self.axis.set_ylabel('Counts')
        self.axis.grid(True)
        
        self.canvas = FigureCanvasGTK(self.figure)
        self.figure.canvas.mpl_connect('pick_event',self.handle_plot_click)
        self.canvas.show()
        
        self.plotView = self.wTree.get_widget("vbox4")
        self.plotView.pack_start(self.canvas, True, True)    
        
        self.metadataView = self.wTree.get_widget("tv_metadata")
        self.mdlist = gtk.ListStore(str,str)
       
        
        #self.filelistview.enable_model_drag_source( gtk.gdk.BUTTON1_MASK,
                #                                  self.TARGETS,
                #                                   gtk.gdk.ACTION_COPY)

        #self.filelistview.connect("drag_data_get", self.dnd_data_getdata)
        
        
    def AddFileListColumns(self):
        """This function adds a column to the list view.
        First it create the gtk.TreeViewColumn and then set
        some needed properties"""
                        
        column = gtk.TreeViewColumn('Filename', gtk.CellRendererText(), text=0)
        column.set_resizable(True)        
        column.set_sort_column_id(0)
        self.filelistview.append_column(column)

        column = gtk.TreeViewColumn('', self.cellrenderertoggle, active=1)
        self.filelistview.append_column(column)
        return
        
    def GetBT5DirList(self):
        """Function to parse the directory listing of the current working directory
             and create a list of filenames that are BT5 data files"""
             
        dirlist = os.listdir(os.getcwd())
        
        bt5list = [ x for x in dirlist if (x.find('.bt5') > 0 and usans.isBT5Data(x))]
        
        return bt5list
        
    
    def FillFileList(self, filenames):
        self.filelist.clear()
        for filename in filenames:
                self.filelist.append([filename, 0, 0, 0, 0])
        return
            
    def RefreshFileList(self,filenames):        
        #print len(filenames)
        
        deletelist = []
        
        treestore = self.filelistview.get_model()
        treestore.foreach(self.filelist_match_filename, (filenames,deletelist))
          
        for filename in filenames:
            self.filelist.append([filename, 0, 0, 0, 0])
        
        deletelist.reverse()
        for path in deletelist:
            treestore.remove(treestore.get_iter(path))
        #print len(filenames)    
        return

    def filelist_match_filename(self, model, path, iter, data):
        
        mval = model.get_value(iter,0)
        
        if mval in data[0]:
            del data[0][data[0].index(mval)]
        else:
            data[1].append(path)
            
        return False
    
    def handle_refreshlist(self,widget):

        self.RefreshFileList(self.GetBT5DirList())
        
        return

    def filter_filelist(self, model, iter, data):
        
        if model.get_value(iter,0):        
            match = re.match(data[0],model.get_value(iter,0))
        else:
            match = None
        
        if match is None:
            return False
        else:
            return True
        
    def handle_filter(self,widget):
        
        print "Filtering"
        del self.filter_string[:]
        self.filter_string.append(self.filter_entry.get_text())
        print self.filter_string[0]
        self.filelistfilter.refilter()
        
        return

    def setdatadir(self, widget):
        
        #Clear plot before selecting new folder
        #This is a bit clunky, but it avoids a lot of pain for the moment
        
        self.clearplot()
        
        chooser = gtk.FileChooserDialog(title="Select Data Directory", action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER,
                                  buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))
        chooser.set_default_response(gtk.RESPONSE_OK)
        chooser.set_current_folder(os.getcwd())
        response = chooser.run()
        if response == gtk.RESPONSE_OK:
            os.chdir(chooser.get_filename())
            self.FillFileList(self.GetBT5DirList())
        chooser.destroy()

    def handle_plot_toggle(self, filter_cell, filter_path, filter_model):
        model = filter_model.get_model()
        path = filter_model.convert_path_to_child_path(filter_path)
        model[path][1] = not model[path][1]

        if model[path][1]:
            #load data
            data,metadata = usans.getBT5DataFromFile(model[path][0])
            model[path][2] = (data,metadata)
            #add plot
            self.add_plot(model, path)
        else:
            #remove plot
            self.remove_plot(model, path)
        return

    def add_plot(self, model, path):
        
        self.make_plottable_dataset(model, path, self.plottype)

        if self.plottype == 'split':
        	model[path][4] = self.axis.plot(model[path][3][0],model[path][3][1], 'o',
											 model[path][3][0],model[path][3][2], 'o',
											 model[path][3][0],model[path][3][3], 'o',
											 model[path][3][0],model[path][3][4], 'o',
											 model[path][3][0],model[path][3][5], 'o')
        else:
            model[path][4] = self.axis.plot(model[path][3][0],model[path][3][1], 'bo', picker=5)
        
        self.rescale_and_redraw()
        #self.canvas.draw()
        return

    def make_plottable_dataset(self, model, path, type):
         
         data,metadata = model[path][2]
                  
         if type == 'total':
             #generate totals
             xdata = []
             ydata = []     
             
             mvals = data.keys()
             mvals.sort(usans.numeric_compare)
             for mval in mvals:
                 xdata.append(mval)
                 ydata.append(data[mval][1] + data[mval][2] + data[mval][4] + data[mval][5] + data[mval][6])
             
             model[path][3] = [xdata, ydata]
             
         elif type == 'rate':
             # generate countrate
             xdata = []
             ydata = []
             
             mvals = data.keys()
             mvals.sort(usans.numeric_compare)
             for mval in mvals:
                 xdata.append(mval)
             
             if metadata['base'] == 'TIME':
             	#Counting in TIME base, so normalize by seconds
             	cnttime = metadata['mon']
             	for mval in mvals:
                     ydata.append((data[mval][1] + data[mval][2] + data[mval][4] + data[mval][5] + data[mval][6])/cnttime)
             else:
             	#Must be counting in monitor base so normalize by monitor
             	moncts = metadata['mon']
                for mval in mvals:
                    ydata.append((data[mval][1] + data[mval][2] + data[mval][4] + data[mval][5] + data[mval][6])/cnttime)
             
             model[path][3] = [xdata, ydata]
             
         elif type == 'trans':
             xdata = []
             ydata = []
             
             mvals = data.keys()
             mvals.sort(usans.numeric_compare)
             for mval in mvals:
                 xdata.append(mval)
                 ydata.append(data[mval][3])
             
             model[path][3] = [xdata, ydata]             
         
         elif type == 'mon':
             xdata = []
             ydata = []
             
             mvals = data.keys()
             mvals.sort(usans.numeric_compare)
             for mval in mvals:
                 xdata.append(mval)
                 ydata.append(data[mval][0])
             
             model[path][3] = [xdata, ydata]             
             
         elif type == 'split':
             xdata = []
             ydata1 = []
             ydata2 = []
             ydata3 = []
             ydata4 = []
             ydata5 = []
             
             mvals = data.keys()
             mvals.sort(usans.numeric_compare)
             for mval in mvals:
                 xdata.append(mval)
                 ydata1.append(data[mval][1])   
                 ydata2.append(data[mval][2])   
                 ydata3.append(data[mval][4])   
                 ydata4.append(data[mval][5])   
                 ydata5.append(data[mval][6])   

             model[path][3] = [xdata,ydata1,ydata2,ydata3,ydata4,ydata5]
         else:
         	pass
             
         return

    def remove_plot(self, model, path):
 
    	for line in model[path][4]:
    		self.axis.lines.remove(line)
    	
        if (len(self.axis.lines) > 0):
	        self.rescale_and_redraw()
    	else:
            self.canvas.draw()	

        return

    def handle_xaxis_loglin(self, widget):


        if (self.axis.get_xscale() == "log"):
            self.axis.set_xscale('linear')
        else:
            self.axis.set_xscale('log')        


        self.rescale_and_redraw()
        
        return    

    def handle_yaxis_loglin(self, widget):


        if (self.axis.get_yscale() == "log"):
            self.axis.set_yscale('linear')
        else:
            self.axis.set_yscale('log')        

        self.canvas.draw()
        return
       
    def handle_plot_type_change(self,widget):
    	    	
    	if widget.get_active():
    		self.plottype = widget.get_name().split('_')[1]
    		#print self.plottype
    		
    	return
    	
    def handle_clearplot(self,widget):
        
        self.clearplot()
        
        return
        
    
    def clearplot(self):
        model = self.filelistview.get_model().get_model()
        iter = model.iter_children(None)
        while iter:
            path = model.get_path(iter)
            if model[path][1] != 0:
                for line in model[path][4]:
                    self.axis.lines.remove(line)   
                    model[path][1] = not model[path][1]         
            iter = model.iter_next(iter)

        #Remove any lines left over - shouldn't be any, but let's tidy up
        #for line in self.axis.lines:
             #self.axis.lines.remove(line)
        
        self.canvas.draw()
        return 
        
    def rescale_and_redraw(self):

        xdata = []
        ydata = []

        for line in self.axis.lines:
        	if self.axis.get_xscale() == 'log':
        		xdata.extend([xval for xval in line.get_xdata() if xval > 0])
        	else:
        		xdata.extend(line.get_xdata())
        	if self.axis.get_yscale() == 'log':
        		ydata.extend([xval for xval in line.get_ydata() if xval > 0])
        	else:
        		ydata.extend(line.get_ydata())
      
        #set limits
        xmin = float(min(xdata))
        xmax = float(max(xdata))
        ymin = float(min(ydata))
        ymax = float(max(ydata))	

        #adjust for size of markers (sort of)
        xmin = xmin - 0.1*abs(xmin)
        xmax = xmax + 0.1*abs(xmax)
        ymin = ymin - 0.1*abs(ymin)
        ymax = ymax + 0.1*abs(ymax)
                
        self.axis.set_xlim(xmin,xmax)
        self.axis.set_ylim(ymin,ymax)
        
        #self.axis.autoscale_view()
        self.canvas.draw()

        return

    def handle_plot_click(self,event):
        if isinstance(event.artist, matplotlib.lines.Line2D):
            pickedline = event.artist
            xdata = pickedline.get_xdata()
            ydata = pickedline.get_ydata()
            ind = event.ind
            print 'Plot Click: ',zip(numpy.take(xdata,ind), numpy.take(ydata,ind))

app = appGui()
gtk.main()
