#!/usr/bin/wish

package require BLT

set images(normal) [image create photo -format gif -data {
    R0lGODlhEAANAMIAAAAAAH9/f///////AL+/vwAA/wAAAAAAACH5BAEAAAUALAAAAAAQAA0A
    AAM1WBrM+rAEMigJ8c3Kb3OSII6kGABhp1JnaK1VGwjwKwtvHqNzzd263M3H4n2OH1QBwGw6
    nQkAOw==
} ]

set images(active) [image create photo -format gif -data {
    R0lGODlhEAANAMIAAAAAAH9/f/////+/AL+/vwAA/wAAAAAAACH5BAEAAAUALAAAAAAQAA0A
    AAM8WBrM+rAEQWmIb5KxiWjNInCkV32AJHRlGQBgDA7vdN4vUa8tC78qlrCWmvRKsJTquHkp
    ZTKAsiCtWq0JADs=
} ]

proc loadBT5File  {fileName x c cr t m} {
	global datasets
	global $x $c $cr $t $m

	#puts "In load proc: $x $c $cr $t $m"

	set lc 0
	set mon(0) 0
	set det1(0) 0
	set det2(0) 0
	set det3(0) 0
	set det4(0) 0
	set det5(0) 0
	set xvar(0) 0
	set trans(0) 0

	if [catch {open $fileName r} fileId] {

		puts stderr "Cannot open file for reading: $fileId"

	} else {
		for {set lc 0} {$lc < 13} {incr lc} {
			gets $fileId line
			if { $lc == 0 } {
				regexp {^\'.+?\' \'.+?\' \'.+?\'.+?(\d+)\..+} $line match counttime
			}
		}	

		set lc 0
		while true {
			if {[gets $fileId line] < 0} {
				break
			} else {
				regexp {^ +([^ ]+).*} $line match xvar($lc)
			}

			gets $fileId line
			regexp {^ (.+?),(.+?),(.+?),(.+?),(.+?),(.+?),(.+?),.*} $line match mon($lc) \
					det2($lc) det1($lc) trans($lc) det3($lc) det4($lc) det5($lc)
			incr lc
		}

		close $fileId
	}

	foreach index [lsort -integer [array names xvar]] {
		$x append {$xvar($index)}
		$c append {$det1($index)+$det2($index)+$det3($index)+$det4($index)+$det5($index)}
		$cr append [expr [$c index $index] / $counttime]
		$t append {$trans($index)}
		$m append {$mon($index)}
	}

}

proc resetGraph { } {
	global graph
	global tv
	global images

	foreach elem [ $graph element show] {
		$graph element delete $elem

		set xvec [join "$elem _xvec" ""]
		set countratevec [join "$elem _countratevec" ""]
		set countvec [join "$elem _countvec" ""]
		set transvec [join "$elem _transvec" ""]
		set monvec [join "$elem _monvec" ""]
	
		global $xvec $countvec $countratevec $transvec $monvec
	
		blt::vector destroy $xvec
		blt::vector destroy $countratevec
		blt::vector destroy $countvec
		blt::vector destroy $transvec 
		blt::vector destroy $monvec
	}
	
	$tv entry configure all -activeicons "$images(normal) $images(normal)"
	$tv entry configure all -icons "$images(normal) $images(normal)"
}

#foreach fileName $argv {
proc addremovePlot { nodeID } {
	global graph
	global tv
	global images
	global .tree
	global plotType
	
	set fileName [.tree label $nodeID]	
	#puts "$nodeID $fileName" 	
	set filebase [string trimright $fileName .bt5]

	if { ! [$graph element exists $filebase] } {

		$tv entry configure $nodeID -activeicons "$images(active) $images(active)"
		$tv entry configure $nodeID -icons "$images(active) $images(active)" 

		set xvec [join "$filebase _xvec" ""]
		set countratevec [join "$filebase _countratevec" ""]
		set countvec [join "$filebase _countvec" ""]
		set transvec [join "$filebase _transvec" ""]
		set monvec [join "$filebase _monvec" ""]
	
		global $xvec $countvec $countratevec $transvec $monvec
	
		blt::vector create $xvec
		blt::vector create $countratevec
		blt::vector create $countvec
		blt::vector create $transvec 
		blt::vector create $monvec

		loadBT5File $fileName $xvec $countvec $countratevec $transvec $monvec

		$graph element create $filebase -symbol scross \
			-xdata $xvec  \
			-ydata $countvec

		switch -exact $plotType {
			count { $graph element configure $filebase -ydata $countvec}
			countrate { $graph element configure $filebase -ydata $countratevec}
			trans { $graph element configure $filebase -ydata $transvec}
			mon { $graph element configure $filebase -ydata  $monvec}
		}

	} else {
		$tv entry configure $nodeID -activeicons "$images(normal) $images(normal)"
		$tv entry configure $nodeID -icons "$images(normal) $images(normal)"		
	
		$graph element delete $filebase
	
		set xvec [join "$filebase _xvec" ""]
		set countratevec [join "$filebase _countratevec" ""]
		set countvec [join "$filebase _countvec" ""]
		set transvec [join "$filebase _transvec" ""]
		set monvec [join "$filebase _monvec" ""]
	
		global $xvec $countvec $transvec $monvec
	
		blt::vector destroy $xvec
		blt::vector destroy $countratevec
		blt::vector destroy $countvec
		blt::vector destroy $transvec 
		blt::vector destroy $monvec

	
	}
}

proc changePlotType {elem} {
	global graph
	global plotType

	set xvec [join "$elem _xvec" ""]
	set countratevec [join "$elem _countratevec" ""]
	set countvec [join "$elem _countvec" ""]
	set transvec [join "$elem _transvec" ""]
	set monvec [join "$elem _monvec" ""]

	global $xvec $countvec $transvec $monvec
	
	switch -exact $plotType {
			count { $graph element configure $elem -ydata $countvec}
			countrate { $graph element configure $elem -ydata $countratevec}
			trans { $graph element configure $elem -ydata $transvec}
			mon { $graph element configure $elem -ydata  $monvec}
	}
}

proc changeLogLinY {} {
	global graph
	global loglinY

	$graph axis configure y -logscale $loglinY
}	

proc changeLogLinX {} {
	global graph
	global loglinX

	$graph axis configure x -logscale $loglinX
}	

proc LoadTree { tree parentNode dir } {
	cd $dir
	foreach f [lsort [glob *.bt5]] {
		set e [$tree insert $parentNode -label $f -data "Plot 0"]
	}
}

proc EmptyTree { tree } {
	$tree delete 0
}

proc selectDirectory {} {
	
	global .tree 
	
	set dir [tk_chooseDirectory -title "Set Data Directory"]

	if {$dir ne ""} {
		EmptyTree .tree
		catch { LoadTree .tree 0 $dir } result
		cd $dir
	}	
}

proc resetTree { } {

	global .tree

	EmptyTree .tree
	LoadTree .tree 0 [pwd]
}


proc filterTree { filterString } {
	
	global .tree

	resetTree
	
	if {$filterString ne ""} {
		set filterlist [.tree find 0 -glob $filterString -invert -depth 1]
		foreach node $filterlist {
			if { $node != 0 } {
				.tree delete $node
			}
		}
	}	
	
}

#Create menu frame
set mf [frame .mf]

# Create File menu
menubutton $mf.filemb -text File -menu $mf.filemb.fileMenu
set fm [menu $mf.filemb.fileMenu -tearoff 0]
$fm add command -label "Set Data Dir" -command selectDirectory

#Create Plot menu
menubutton $mf.plotmb -text Plot -menu $mf.plotmb.plotMenu
set pm [menu $mf.plotmb.plotMenu -tearoff 0]
$pm add cascade -label "Type" -menu $pm.type
$pm add cascade -label "X-Axis" -menu $pm.xaxis
$pm add cascade -label "Y-Axis" -menu $pm.yaxis
#Create sub menus
set xam [menu $pm.xaxis -tearoff 0]
$xam add radio -label "Lin" -variable loglinX -value "no" -command {changeLogLinX}
$xam add radio -label "Log" -variable loglinX -value "yes" -command {changeLogLinX}

set yam [menu $pm.yaxis -tearoff 0]
$yam add radio -label "Lin" -variable loglinY -value "no" -command {changeLogLinY}
$yam add radio -label "Log" -variable loglinY -value "yes" -command {changeLogLinY}

set ptm [menu $pm.type -tearoff 0]
$ptm add radio  -label "Counts" -variable plotType -value "count" -command {foreach elem [$graph element show] { changePlotType $elem  }}
$ptm add radio -label "Count Rate" -variable plotType -value "countrate" -command {foreach elem [$graph element show] { changePlotType $elem  }}
$ptm add radio -label "Trans" -variable plotType -value "trans" -command {foreach elem [$graph element show] { changePlotType $elem  }}
$ptm add radio -label "Mon" -variable plotType -value "mon" -command {foreach elem [$graph element show] { changePlotType $elem  }}

#pack menubuttons into menu
pack $mf.filemb -side left
pack $mf.plotmb -side left

# Create tree
blt::tree create .tree
catch { LoadTree .tree 0 [pwd] } result

# Create view+plot frame
frame .vp
# Create treeview frame
set tvf [frame .vp.tvf]

set tv [blt::treeview $tvf.t -tree .tree -scrollmode listbox \
					-xscrollcommand "$tvf.xscroll set" \
					-yscrollcommand "$tvf.yscroll set" \
					-activeicons "$images(normal) $images(normal)" \
					-icons "$images(normal) $images(normal)"]
#$tvf.t column insert end Plot
scrollbar $tvf.xscroll -orient horizontal -command "$tvf.t xview"
scrollbar $tvf.yscroll -orient vertical -command "$tvf.t yview"

#$tvf.t bind all <ButtonPress-1> {puts stdout [.tree label [%W curselection]]}
$tvf.t bind all <ButtonPress-1> {addremovePlot [%W curselection]}

pack $tvf.xscroll -side bottom -fill x
pack $tvf.yscroll -side right -fill y
pack $tvf.t -side left -fill both -expand true
pack $tvf -side left -fill y -anchor w

# Create graph
set graph [blt::graph .vp.g]
pack $graph -fill both -expand true -side left -anchor w

# Create filter frame
frame .filter
label .filter.filterLabel -text "Filter: "
entry .filter.filterEntry
bind .filter.filterEntry <Return> {filterTree [%W get]}

#button .filter.filterButton -text "Filter" -command {filterTree [.filter.filterEntry get]} 
pack .filter.filterLabel -side left
pack .filter.filterEntry -side left 
#pack .filter.filterButton -side left
#pack .filter.filterReset -side right -padx 25

#Plot controls
set pcf [frame .filter.pc]
#Clear plot button
button $pcf.filterReset -text "Clear Plot" -command {resetGraph}

##Frame for radiobutton set to control plot type
#set ptf [frame .filter.pc.pt -borderwidth 1 -relief raised]
#radiobutton $ptf.c -text "Counts" -variable plotType -value "count" -command {foreach elem [$graph element show] { changePlotType $elem  }}
#radiobutton $ptf.cr -text "Count Rate" -variable plotType -value "countrate" -command {foreach elem [$graph element show] { changePlotType $elem  }}
#radiobutton $ptf.t -text "Trans" -variable plotType -value "trans" -command {foreach elem [$graph element show] { changePlotType $elem  }}
#radiobutton $ptf.m -text "Mon" -variable plotType -value "mon" -command {foreach elem [$graph element show] { changePlotType $elem  }}
#$ptf.c select
#pack $ptf.m -side right
#pack $ptf.t -side right
#pack $ptf.cr -side right
#pack $ptf.c -side right 

##Frame for y-axis log/lin choice
#set logfy [frame .filter.pc.logy -borderwidth 1 -relief raised]
##Log/lin radiobutton set
#radiobutton $logfy.log -text "Log Y" -variable loglinY -value "yes" -command { changeLogLinY }
#radiobutton $logfy.lin -text "Lin Y" -variable loglinY -value "no" -command { changeLogLinY }
#$logfy.lin select
#pack $logfy.log -side right
#pack $logfy.lin -side right

##Frame for y-axis log/lin choice
#set logfx [frame .filter.pc.logx -borderwidth 1 -relief raised]
##Log/lin radiobutton set
#radiobutton $logfx.log -text "Log X" -variable loglinX -value "yes" -command { changeLogLinX }
#radiobutton $logfx.lin -text "Lin X" -variable loglinX -value "no" -command { changeLogLinX }
#$logfx.lin select
#pack $logfx.log -side right
#pack $logfx.lin -side right

pack $pcf.filterReset -side right -padx 25
#pack $logfy -side right
#pack $logfx -side right
#pack $ptf -side right
pack $pcf -side right


# Pack  widgets
pack $mf -side top -anchor w
pack .vp -fill both -expand true -anchor w
pack .filter -side bottom -fill x -anchor sw

Blt_ZoomStack $graph




